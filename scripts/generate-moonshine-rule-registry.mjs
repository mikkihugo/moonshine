#!/usr/bin/env node
/*
  Generate Rust registry for MoonShine rules from local JS rule sources.
  - Scans moonshine-rules/common/*.js and moonshine-rules/security/*.js
  - Extracts rule id (e.g., C029, S058) from filename
  - Extracts description from meta.docs.description or top comment (best-effort)
  - Writes src/rules/registry_autogen.rs with a register_rules() function

  Usage:
    node scripts/generate-moonshine-rule-registry.mjs
*/

import { promises as fs } from 'fs';
import path from 'path';

const ROOT = path.resolve(process.cwd(), 'packages/tools/moon-shine');
const SRC_DIR = path.join(ROOT, 'src');
const RULES_DIR = path.join(ROOT, 'moonshine-rules');
const COMMON_DIR = path.join(RULES_DIR, 'common');
const SECURITY_DIR = path.join(RULES_DIR, 'security');
const OUT_FILE = path.join(SRC_DIR, 'rules', 'registry_autogen.rs');

/** Recursively list files ending with .js under a directory (non-deep by default) */
async function listJsFiles(dir) {
  try {
    const entries = await fs.readdir(dir, { withFileTypes: true });
    const files = [];
    for (const e of entries) {
      const full = path.join(dir, e.name);
      if (e.isFile() && e.name.toLowerCase().endsWith('.js')) {
        files.push(full);
      } else if (e.isDirectory()) {
        // Some rules are stored inside their own directories; include top-level js files inside
        try {
          const sub = await fs.readdir(full, { withFileTypes: true });
          for (const s of sub) {
            const subFull = path.join(full, s.name);
            if (s.isFile() && s.name.toLowerCase().endsWith('.js')) {
              files.push(subFull);
            }
          }
        } catch {}
      }
    }
    return files;
  } catch {
    return [];
  }
}

function extractRuleId(filePath) {
  const name = path.basename(filePath).toLowerCase();
  // Prefer directory-based ID if parent dir matches pattern like C029_*
  const parent = path.basename(path.dirname(filePath));
  const mDir = parent.match(/^([cs])(\d{3})/i);
  if (mDir) {
    return `${mDir[1].toUpperCase()}${mDir[2]}`;
  }
  // Fallback to filename e.g., c029-catch-block-logging.js
  const m = name.match(/^([cs])(\d{3})/i);
  if (m) {
    return `${m[1].toUpperCase()}${m[2]}`;
  }
  return null;
}

function extractDescription(content) {
  // Try meta.docs.description
  const m1 = content.match(/description\s*:\s*"([^"]+)"/i);
  if (m1) return m1[1].trim();
  // Try first block comment line
  const m2 = content.match(/\/\*\*([\s\S]*?)\*\//);
  if (m2) {
    const lines = m2[1].split('\n').map(l => l.replace(/^\s*\*\s?/, '').trim()).filter(Boolean);
    if (lines.length) return lines[0].slice(0, 200);
  }
  // Fallback
  return 'Auto-registered rule (description unavailable)';
}

function pickCategory(ruleId) {
  if (!ruleId) return 'CodeQuality';
  if (ruleId.startsWith('S')) return 'Security';
  return 'CodeQuality';
}

async function loadRulesFrom(dir) {
  const files = await listJsFiles(dir);
  const items = [];
  for (const f of files) {
    try {
      const id = extractRuleId(f);
      if (!id) continue;
      const content = await fs.readFile(f, 'utf8');
      const description = extractDescription(content);
      items.push({ id, description, file: f, category: pickCategory(id) });
    } catch {}
  }
  return items;
}

function rustEscape(s) {
  return s.replace(/\\/g, "\\\\").replace(/"/g, '\\"');
}

function generateRust(items) {
  const header = `// AUTO-GENERATED: Do not edit by hand.\n// Generated by scripts/generate-moonshine-rule-registry.mjs\n\nuse std::collections::HashMap;\nuse crate::wasm_safe_linter::LintSeverity;\nuse super::engine::{MoonShineRule, MoonShineRuleCategory, RuleImplementation};\n\n/// Registers all auto-generated rules from JS references (SunLint / Moonshine).\npub fn register_rules(rules: &mut HashMap<String, MoonShineRule>) {\n`;
  const lines = items.sort((a,b)=> a.id.localeCompare(b.id)).map(it => {
    const desc = rustEscape(it.description);
    const cat = it.category;
    return `    rules.insert("${it.id}".to_string(), MoonShineRule {\n        id: "${it.id}".to_string(),\n        category: MoonShineRuleCategory::${cat},\n        severity: LintSeverity::Warning,\n        description: "${desc}".to_string(),\n        ai_enhanced: true,\n        implementation: RuleImplementation::AiAssisted,\n    });`;
  });
  const footer = `}\n`;
  return header + lines.join('\n') + '\n' + footer;
}

async function main() {
  const common = await loadRulesFrom(COMMON_DIR);
  const security = await loadRulesFrom(SECURITY_DIR);
  const all = [...common, ...security];
  if (all.length === 0) {
    console.error('No rules discovered. Ensure moonshine-rules directory exists.');
    process.exit(1);
  }
  const out = generateRust(all);
  await fs.mkdir(path.dirname(OUT_FILE), { recursive: true });
  await fs.writeFile(OUT_FILE, out, 'utf8');
  console.log(`Generated ${all.length} entries -> ${path.relative(ROOT, OUT_FILE)}`);
}

main().catch(err => {
  console.error(err);
  process.exit(1);
});
